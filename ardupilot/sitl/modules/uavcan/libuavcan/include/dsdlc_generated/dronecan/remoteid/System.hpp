/*
 * UAVCAN data structure definition for libuavcan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/user/cyberimmune-systems-autonomous-delivery-drone-with-kos-contest/modules/DroneCAN/DSDL/dronecan/remoteid/20033.System.uavcan
 */

#ifndef DRONECAN_REMOTEID_SYSTEM_HPP_INCLUDED
#define DRONECAN_REMOTEID_SYSTEM_HPP_INCLUDED

#include <uavcan/build_config.hpp>
#include <uavcan/node/global_data_type_registry.hpp>
#include <uavcan/marshal/types.hpp>

/******************************* Source text **********************************
#
# DroneCAN version of MAVLink OPEN_DRONE_ID_SYSTEM
# see MAVLink XML for detailed description
#
uint8[<=20] id_or_mac

uint8 ODID_OPERATOR_LOCATION_TYPE_TAKEOFF = 0 # The location of the operator is the same as the take-off location
uint8 ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS = 1 # The location of the operator is based on live GNSS data
uint8 ODID_OPERATOR_LOCATION_TYPE_FIXED = 2 # The location of the operator is a fixed location
uint8 operator_location_type

uint8 ODID_CLASSIFICATION_TYPE_EU = 0
uint8 classification_type

int32 operator_latitude # degE7
int32 operator_longitude # degE7
uint16 area_count # default 1
uint16 area_radius # meters
float32 area_ceiling # meters, use -1000 if unknown, WGS84
float32 area_floor # meters, use -1000 if unknown, WGS84

uint8 ODID_CATEGORY_EU_UNDECLARED = 0 # The category for the UA, according to the EU specification, is undeclared
uint8 ODID_CATEGORY_EU_OPEN = 1 # The category for the UA, according to the EU specification, is the Open category
uint8 ODID_CATEGORY_EU_SPECIFIC = 2 # The category for the UA, according to the EU specification, is the Specific category
uint8 ODID_CATEGORY_EU_CERTIFIED = 3 # The category for the UA, according to the EU specification, is the Certified category
uint8 category_eu

uint8 ODID_CLASS_EU_UNDECLARED = 0 # The class for the UA, according to the EU specification, is undeclared
uint8 ODID_CLASS_EU_CLASS_0 = 1 # The class for the UA, according to the EU specification, is Class 0
uint8 ODID_CLASS_EU_CLASS_1 = 2 # The class for the UA, according to the EU specification, is Class 1
uint8 ODID_CLASS_EU_CLASS_2 = 3 # The class for the UA, according to the EU specification, is Class 2
uint8 ODID_CLASS_EU_CLASS_3 = 4 # The class for the UA, according to the EU specification, is Class 3
uint8 ODID_CLASS_EU_CLASS_4 = 5 # The class for the UA, according to the EU specification, is Class 4
uint8 ODID_CLASS_EU_CLASS_5 = 6 # The class for the UA, according to the EU specification, is Class 5
uint8 ODID_CLASS_EU_CLASS_6 = 7 # The class for the UA, according to the EU specification, is Class 6
uint8 class_eu

float32 operator_altitude_geo # meters, use -1000 if unknown, WGS84
uint32 timestamp # Unix seconds since 00:00:00 01/01/2019
******************************************************************************/

/********************* DSDL signature source definition ***********************
dronecan.remoteid.System
saturated uint8[<=20] id_or_mac
saturated uint8 operator_location_type
saturated uint8 classification_type
saturated int32 operator_latitude
saturated int32 operator_longitude
saturated uint16 area_count
saturated uint16 area_radius
saturated float32 area_ceiling
saturated float32 area_floor
saturated uint8 category_eu
saturated uint8 class_eu
saturated float32 operator_altitude_geo
saturated uint32 timestamp
******************************************************************************/

#undef id_or_mac
#undef operator_location_type
#undef classification_type
#undef operator_latitude
#undef operator_longitude
#undef area_count
#undef area_radius
#undef area_ceiling
#undef area_floor
#undef category_eu
#undef class_eu
#undef operator_altitude_geo
#undef timestamp
#undef ODID_OPERATOR_LOCATION_TYPE_TAKEOFF
#undef ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS
#undef ODID_OPERATOR_LOCATION_TYPE_FIXED
#undef ODID_CLASSIFICATION_TYPE_EU
#undef ODID_CATEGORY_EU_UNDECLARED
#undef ODID_CATEGORY_EU_OPEN
#undef ODID_CATEGORY_EU_SPECIFIC
#undef ODID_CATEGORY_EU_CERTIFIED
#undef ODID_CLASS_EU_UNDECLARED
#undef ODID_CLASS_EU_CLASS_0
#undef ODID_CLASS_EU_CLASS_1
#undef ODID_CLASS_EU_CLASS_2
#undef ODID_CLASS_EU_CLASS_3
#undef ODID_CLASS_EU_CLASS_4
#undef ODID_CLASS_EU_CLASS_5
#undef ODID_CLASS_EU_CLASS_6

namespace dronecan
{
namespace remoteid
{

template <int _tmpl>
struct UAVCAN_EXPORT System_
{
    typedef const System_<_tmpl>& ParameterType;
    typedef System_<_tmpl>& ReferenceType;

    struct ConstantTypes
    {
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_OPERATOR_LOCATION_TYPE_TAKEOFF;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_OPERATOR_LOCATION_TYPE_FIXED;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CLASSIFICATION_TYPE_EU;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CATEGORY_EU_UNDECLARED;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CATEGORY_EU_OPEN;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CATEGORY_EU_SPECIFIC;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CATEGORY_EU_CERTIFIED;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CLASS_EU_UNDECLARED;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CLASS_EU_CLASS_0;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CLASS_EU_CLASS_1;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CLASS_EU_CLASS_2;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CLASS_EU_CLASS_3;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CLASS_EU_CLASS_4;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CLASS_EU_CLASS_5;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ODID_CLASS_EU_CLASS_6;
    };

    struct FieldTypes
    {
        typedef ::uavcan::Array< ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate >, ::uavcan::ArrayModeDynamic, 20 > id_or_mac;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > operator_location_type;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > classification_type;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessSigned, ::uavcan::CastModeSaturate > operator_latitude;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessSigned, ::uavcan::CastModeSaturate > operator_longitude;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > area_count;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > area_radius;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > area_ceiling;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > area_floor;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > category_eu;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > class_eu;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > operator_altitude_geo;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > timestamp;
    };

    enum
    {
        MinBitLen
            = FieldTypes::id_or_mac::MinBitLen
            + FieldTypes::operator_location_type::MinBitLen
            + FieldTypes::classification_type::MinBitLen
            + FieldTypes::operator_latitude::MinBitLen
            + FieldTypes::operator_longitude::MinBitLen
            + FieldTypes::area_count::MinBitLen
            + FieldTypes::area_radius::MinBitLen
            + FieldTypes::area_ceiling::MinBitLen
            + FieldTypes::area_floor::MinBitLen
            + FieldTypes::category_eu::MinBitLen
            + FieldTypes::class_eu::MinBitLen
            + FieldTypes::operator_altitude_geo::MinBitLen
            + FieldTypes::timestamp::MinBitLen
    };

    enum
    {
        MaxBitLen
            = FieldTypes::id_or_mac::MaxBitLen
            + FieldTypes::operator_location_type::MaxBitLen
            + FieldTypes::classification_type::MaxBitLen
            + FieldTypes::operator_latitude::MaxBitLen
            + FieldTypes::operator_longitude::MaxBitLen
            + FieldTypes::area_count::MaxBitLen
            + FieldTypes::area_radius::MaxBitLen
            + FieldTypes::area_ceiling::MaxBitLen
            + FieldTypes::area_floor::MaxBitLen
            + FieldTypes::category_eu::MaxBitLen
            + FieldTypes::class_eu::MaxBitLen
            + FieldTypes::operator_altitude_geo::MaxBitLen
            + FieldTypes::timestamp::MaxBitLen
    };

    // Constants
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_OPERATOR_LOCATION_TYPE_TAKEOFF >::Type ODID_OPERATOR_LOCATION_TYPE_TAKEOFF; // 0
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS >::Type ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_OPERATOR_LOCATION_TYPE_FIXED >::Type ODID_OPERATOR_LOCATION_TYPE_FIXED; // 2
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CLASSIFICATION_TYPE_EU >::Type ODID_CLASSIFICATION_TYPE_EU; // 0
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CATEGORY_EU_UNDECLARED >::Type ODID_CATEGORY_EU_UNDECLARED; // 0
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CATEGORY_EU_OPEN >::Type ODID_CATEGORY_EU_OPEN; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CATEGORY_EU_SPECIFIC >::Type ODID_CATEGORY_EU_SPECIFIC; // 2
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CATEGORY_EU_CERTIFIED >::Type ODID_CATEGORY_EU_CERTIFIED; // 3
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CLASS_EU_UNDECLARED >::Type ODID_CLASS_EU_UNDECLARED; // 0
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CLASS_EU_CLASS_0 >::Type ODID_CLASS_EU_CLASS_0; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CLASS_EU_CLASS_1 >::Type ODID_CLASS_EU_CLASS_1; // 2
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CLASS_EU_CLASS_2 >::Type ODID_CLASS_EU_CLASS_2; // 3
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CLASS_EU_CLASS_3 >::Type ODID_CLASS_EU_CLASS_3; // 4
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CLASS_EU_CLASS_4 >::Type ODID_CLASS_EU_CLASS_4; // 5
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CLASS_EU_CLASS_5 >::Type ODID_CLASS_EU_CLASS_5; // 6
    static const typename ::uavcan::StorageType< typename ConstantTypes::ODID_CLASS_EU_CLASS_6 >::Type ODID_CLASS_EU_CLASS_6; // 7

    // Fields
    typename ::uavcan::StorageType< typename FieldTypes::id_or_mac >::Type id_or_mac;
    typename ::uavcan::StorageType< typename FieldTypes::operator_location_type >::Type operator_location_type;
    typename ::uavcan::StorageType< typename FieldTypes::classification_type >::Type classification_type;
    typename ::uavcan::StorageType< typename FieldTypes::operator_latitude >::Type operator_latitude;
    typename ::uavcan::StorageType< typename FieldTypes::operator_longitude >::Type operator_longitude;
    typename ::uavcan::StorageType< typename FieldTypes::area_count >::Type area_count;
    typename ::uavcan::StorageType< typename FieldTypes::area_radius >::Type area_radius;
    typename ::uavcan::StorageType< typename FieldTypes::area_ceiling >::Type area_ceiling;
    typename ::uavcan::StorageType< typename FieldTypes::area_floor >::Type area_floor;
    typename ::uavcan::StorageType< typename FieldTypes::category_eu >::Type category_eu;
    typename ::uavcan::StorageType< typename FieldTypes::class_eu >::Type class_eu;
    typename ::uavcan::StorageType< typename FieldTypes::operator_altitude_geo >::Type operator_altitude_geo;
    typename ::uavcan::StorageType< typename FieldTypes::timestamp >::Type timestamp;

    System_()
        : id_or_mac()
        , operator_location_type()
        , classification_type()
        , operator_latitude()
        , operator_longitude()
        , area_count()
        , area_radius()
        , area_ceiling()
        , area_floor()
        , category_eu()
        , class_eu()
        , operator_altitude_geo()
        , timestamp()
    {
        ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

#if UAVCAN_DEBUG
        /*
         * Cross-checking MaxBitLen provided by the DSDL compiler.
         * This check shall never be performed in user code because MaxBitLen value
         * actually depends on the nested types, thus it is not invariant.
         */
        ::uavcan::StaticAssert<421 == MaxBitLen>::check();
#endif
    }

    bool operator==(ParameterType rhs) const;
    bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

    /**
     * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
     * floating point fields at any depth.
     */
    bool isClose(ParameterType rhs) const;

    static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    /*
     * Static type info
     */
    enum { DataTypeKind = ::uavcan::DataTypeKindMessage };
    enum { DefaultDataTypeID = 20033 };

    static const char* getDataTypeFullName()
    {
        return "dronecan.remoteid.System";
    }

    static void extendDataTypeSignature(::uavcan::DataTypeSignature& signature)
    {
        signature.extend(getDataTypeSignature());
    }

    static ::uavcan::DataTypeSignature getDataTypeSignature();

};

/*
 * Out of line struct method definitions
 */

template <int _tmpl>
bool System_<_tmpl>::operator==(ParameterType rhs) const
{
    return
        id_or_mac == rhs.id_or_mac &&
        operator_location_type == rhs.operator_location_type &&
        classification_type == rhs.classification_type &&
        operator_latitude == rhs.operator_latitude &&
        operator_longitude == rhs.operator_longitude &&
        area_count == rhs.area_count &&
        area_radius == rhs.area_radius &&
        area_ceiling == rhs.area_ceiling &&
        area_floor == rhs.area_floor &&
        category_eu == rhs.category_eu &&
        class_eu == rhs.class_eu &&
        operator_altitude_geo == rhs.operator_altitude_geo &&
        timestamp == rhs.timestamp;
}

template <int _tmpl>
bool System_<_tmpl>::isClose(ParameterType rhs) const
{
    return
        ::uavcan::areClose(id_or_mac, rhs.id_or_mac) &&
        ::uavcan::areClose(operator_location_type, rhs.operator_location_type) &&
        ::uavcan::areClose(classification_type, rhs.classification_type) &&
        ::uavcan::areClose(operator_latitude, rhs.operator_latitude) &&
        ::uavcan::areClose(operator_longitude, rhs.operator_longitude) &&
        ::uavcan::areClose(area_count, rhs.area_count) &&
        ::uavcan::areClose(area_radius, rhs.area_radius) &&
        ::uavcan::areClose(area_ceiling, rhs.area_ceiling) &&
        ::uavcan::areClose(area_floor, rhs.area_floor) &&
        ::uavcan::areClose(category_eu, rhs.category_eu) &&
        ::uavcan::areClose(class_eu, rhs.class_eu) &&
        ::uavcan::areClose(operator_altitude_geo, rhs.operator_altitude_geo) &&
        ::uavcan::areClose(timestamp, rhs.timestamp);
}

template <int _tmpl>
int System_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::id_or_mac::encode(self.id_or_mac, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::operator_location_type::encode(self.operator_location_type, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::classification_type::encode(self.classification_type, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::operator_latitude::encode(self.operator_latitude, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::operator_longitude::encode(self.operator_longitude, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::area_count::encode(self.area_count, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::area_radius::encode(self.area_radius, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::area_ceiling::encode(self.area_ceiling, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::area_floor::encode(self.area_floor, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::category_eu::encode(self.category_eu, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::class_eu::encode(self.class_eu, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::operator_altitude_geo::encode(self.operator_altitude_geo, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::timestamp::encode(self.timestamp, codec,  tao_mode);
    return res;
}

template <int _tmpl>
int System_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::id_or_mac::decode(self.id_or_mac, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::operator_location_type::decode(self.operator_location_type, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::classification_type::decode(self.classification_type, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::operator_latitude::decode(self.operator_latitude, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::operator_longitude::decode(self.operator_longitude, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::area_count::decode(self.area_count, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::area_radius::decode(self.area_radius, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::area_ceiling::decode(self.area_ceiling, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::area_floor::decode(self.area_floor, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::category_eu::decode(self.category_eu, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::class_eu::decode(self.class_eu, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::operator_altitude_geo::decode(self.operator_altitude_geo, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::timestamp::decode(self.timestamp, codec,  tao_mode);
    return res;
}

/*
 * Out of line type method definitions
 */
template <int _tmpl>
::uavcan::DataTypeSignature System_<_tmpl>::getDataTypeSignature()
{
    ::uavcan::DataTypeSignature signature(0x9AC872F49BF32437ULL);

    FieldTypes::id_or_mac::extendDataTypeSignature(signature);
    FieldTypes::operator_location_type::extendDataTypeSignature(signature);
    FieldTypes::classification_type::extendDataTypeSignature(signature);
    FieldTypes::operator_latitude::extendDataTypeSignature(signature);
    FieldTypes::operator_longitude::extendDataTypeSignature(signature);
    FieldTypes::area_count::extendDataTypeSignature(signature);
    FieldTypes::area_radius::extendDataTypeSignature(signature);
    FieldTypes::area_ceiling::extendDataTypeSignature(signature);
    FieldTypes::area_floor::extendDataTypeSignature(signature);
    FieldTypes::category_eu::extendDataTypeSignature(signature);
    FieldTypes::class_eu::extendDataTypeSignature(signature);
    FieldTypes::operator_altitude_geo::extendDataTypeSignature(signature);
    FieldTypes::timestamp::extendDataTypeSignature(signature);

    return signature;
}

/*
 * Out of line constant definitions
 */

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_OPERATOR_LOCATION_TYPE_TAKEOFF >::Type
    System_<_tmpl>::ODID_OPERATOR_LOCATION_TYPE_TAKEOFF = 0U; // 0

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS >::Type
    System_<_tmpl>::ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_OPERATOR_LOCATION_TYPE_FIXED >::Type
    System_<_tmpl>::ODID_OPERATOR_LOCATION_TYPE_FIXED = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CLASSIFICATION_TYPE_EU >::Type
    System_<_tmpl>::ODID_CLASSIFICATION_TYPE_EU = 0U; // 0

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CATEGORY_EU_UNDECLARED >::Type
    System_<_tmpl>::ODID_CATEGORY_EU_UNDECLARED = 0U; // 0

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CATEGORY_EU_OPEN >::Type
    System_<_tmpl>::ODID_CATEGORY_EU_OPEN = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CATEGORY_EU_SPECIFIC >::Type
    System_<_tmpl>::ODID_CATEGORY_EU_SPECIFIC = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CATEGORY_EU_CERTIFIED >::Type
    System_<_tmpl>::ODID_CATEGORY_EU_CERTIFIED = 3U; // 3

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CLASS_EU_UNDECLARED >::Type
    System_<_tmpl>::ODID_CLASS_EU_UNDECLARED = 0U; // 0

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CLASS_EU_CLASS_0 >::Type
    System_<_tmpl>::ODID_CLASS_EU_CLASS_0 = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CLASS_EU_CLASS_1 >::Type
    System_<_tmpl>::ODID_CLASS_EU_CLASS_1 = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CLASS_EU_CLASS_2 >::Type
    System_<_tmpl>::ODID_CLASS_EU_CLASS_2 = 3U; // 3

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CLASS_EU_CLASS_3 >::Type
    System_<_tmpl>::ODID_CLASS_EU_CLASS_3 = 4U; // 4

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CLASS_EU_CLASS_4 >::Type
    System_<_tmpl>::ODID_CLASS_EU_CLASS_4 = 5U; // 5

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CLASS_EU_CLASS_5 >::Type
    System_<_tmpl>::ODID_CLASS_EU_CLASS_5 = 6U; // 6

template <int _tmpl>
const typename ::uavcan::StorageType< typename System_<_tmpl>::ConstantTypes::ODID_CLASS_EU_CLASS_6 >::Type
    System_<_tmpl>::ODID_CLASS_EU_CLASS_6 = 7U; // 7

/*
 * Final typedef
 */
typedef System_<0> System;

namespace
{

const ::uavcan::DefaultDataTypeRegistrator< ::dronecan::remoteid::System > _uavcan_gdtr_registrator_System;

}

} // Namespace remoteid
} // Namespace dronecan

/*
 * YAML streamer specialization
 */
namespace uavcan
{

template <>
class UAVCAN_EXPORT YamlStreamer< ::dronecan::remoteid::System >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::dronecan::remoteid::System::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::dronecan::remoteid::System >::stream(Stream& s, ::dronecan::remoteid::System::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
    if (level > 0)
    {
        s << '\n';
        for (int pos = 0; pos < level; pos++)
        {
            s << "  ";
        }
    }
    s << "id_or_mac: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::id_or_mac >::stream(s, obj.id_or_mac, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "operator_location_type: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::operator_location_type >::stream(s, obj.operator_location_type, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "classification_type: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::classification_type >::stream(s, obj.classification_type, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "operator_latitude: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::operator_latitude >::stream(s, obj.operator_latitude, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "operator_longitude: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::operator_longitude >::stream(s, obj.operator_longitude, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "area_count: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::area_count >::stream(s, obj.area_count, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "area_radius: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::area_radius >::stream(s, obj.area_radius, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "area_ceiling: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::area_ceiling >::stream(s, obj.area_ceiling, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "area_floor: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::area_floor >::stream(s, obj.area_floor, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "category_eu: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::category_eu >::stream(s, obj.category_eu, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "class_eu: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::class_eu >::stream(s, obj.class_eu, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "operator_altitude_geo: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::operator_altitude_geo >::stream(s, obj.operator_altitude_geo, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "timestamp: ";
    YamlStreamer< ::dronecan::remoteid::System::FieldTypes::timestamp >::stream(s, obj.timestamp, level + 1);
}

}

namespace dronecan
{
namespace remoteid
{

template <typename Stream>
inline Stream& operator<<(Stream& s, ::dronecan::remoteid::System::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::dronecan::remoteid::System >::stream(s, obj, 0);
    return s;
}

} // Namespace remoteid
} // Namespace dronecan

#endif // DRONECAN_REMOTEID_SYSTEM_HPP_INCLUDED